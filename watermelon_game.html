<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>ìˆ˜ë°•ê²Œì„</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Pretendard:wght@400;700&family=Noto+Sans+KR:wght@400;700&display=swap');
    body {
      min-height: 100vh;
      margin: 0;
      font-family: 'Pretendard', 'Noto Sans KR', Arial, sans-serif;
      background: linear-gradient(135deg, #f9e7fe 0%, #b2e6ff 100%);
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding-top: 8px;
    }
    .container {
      max-width: 420px;
      margin: 12px auto 0 auto;
      background: rgba(255,255,255,0.85);
      border-radius: 24px;
      box-shadow: 0 4px 24px #b2e6ff88, 0 1.5px 8px #f9e7fe44;
      padding: 16px 8px 12px 8px;
      position: relative;
    }
    h1 {
      text-align: center;
      color: #7d5fff;
      margin-bottom: 8px;
      font-size: 1.3em;
      letter-spacing: 1px;
      font-family: 'Pretendard', 'Noto Sans KR', Arial, sans-serif;
      text-shadow: 0 2px 8px #b2e6ff55;
    }
    .scoreboard {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      background: rgba(186, 230, 253, 0.45);
      border-radius: 12px;
      box-shadow: 0 1.5px 8px #b2e6ff33;
      padding: 6px 10px;
      font-size: 0.98em;
    }
    .score {
      font-size: 1em;
      font-weight: bold;
      color: #00b894;
      letter-spacing: 0.5px;
      text-shadow: 0 1px 4px #fff8;
    }
    .reset-btn {
      background: linear-gradient(90deg, #f9e7fe 0%, #b2e6ff 100%);
      color: #7d5fff;
      border: none;
      border-radius: 10px;
      padding: 6px 14px;
      font-size: 0.98em;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 2px 8px #b2e6ff33;
      transition: background 0.2s, color 0.2s, transform 0.1s;
    }
    .reset-btn:hover, .reset-btn:active {
      background: linear-gradient(90deg, #b2e6ff 0%, #f9e7fe 100%);
      color: #00b894;
      transform: scale(1.06);
    }
    #gameCanvas {
      display: block;
      margin: 0 auto;
      background: linear-gradient(180deg, #f9e7fe 0%, #b2e6ff 100%);
      border-radius: 24px;
      box-shadow: 0 4px 24px #b2e6ff55, 0 1.5px 8px #f9e7fe33;
      border: 2.5px solid #b2e6ff;
      transition: box-shadow 0.2s;
      width: 96vw;
      max-width: 420px;
      aspect-ratio: 4/5;
      height: auto;
      max-height: 525px;
    }
    #gameCanvas:active {
      box-shadow: 0 2px 8px #b2e6ff88;
    }
    @media (max-width: 500px) {
      .container { max-width: 98vw; padding: 2vw 1vw 2vw 1vw; }
      h1 { font-size: 1.05em; margin-bottom: 2vw; }
      .scoreboard { font-size: 0.92em; padding: 2vw 2vw; margin-bottom: 1vw; }
      .score { font-size: 0.95em; }
      .reset-btn { font-size: 0.95em; padding: 4px 8vw; }
      #gameCanvas { width: 96vw !important; max-width: 420px; aspect-ratio: 4/5; height: auto !important; max-height: 525px !important; }
    }
    #gameOverLayer {
      position: absolute;
      left: 0; top: 0; right: 0; bottom: 0;
      width: 100%; height: 100%;
      background: rgba(186,230,253,0.75);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      border-radius: 24px;
      box-shadow: 0 4px 24px #b2e6ff88, 0 1.5px 8px #f9e7fe44;
      transition: background 0.3s;
    }
    .gameover-content {
      background: rgba(255,255,255,0.95);
      border-radius: 20px;
      box-shadow: 0 2px 12px #b2e6ff55;
      padding: 36px 32px 28px 32px;
      text-align: center;
      min-width: 220px;
    }
    .gameover-title {
      font-size: 2em;
      color: #7d5fff;
      font-weight: bold;
      margin-bottom: 12px;
      letter-spacing: 1px;
      text-shadow: 0 2px 8px #b2e6ff33;
    }
    .gameover-score {
      font-size: 1.2em;
      color: #00b894;
      margin-bottom: 18px;
      font-weight: bold;
      text-shadow: 0 1px 4px #fff8;
    }
    .gameover-btn {
      background: linear-gradient(90deg, #f9e7fe 0%, #b2e6ff 100%);
      color: #7d5fff;
      border: none;
      border-radius: 12px;
      padding: 10px 32px;
      font-size: 1.1em;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 2px 8px #b2e6ff33;
      transition: background 0.2s, color 0.2s, transform 0.1s;
    }
    .gameover-btn:hover, .gameover-btn:active {
      background: linear-gradient(90deg, #b2e6ff 0%, #f9e7fe 100%);
      color: #00b894;
      transform: scale(1.06);
    }
    .custom-img-bar {
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      margin-top: 12px;
      margin-bottom: 2px;
    }
    .custom-img-text {
      color: #7d5fff;
      font-size: 1.08em;
      font-weight: bold;
      cursor: pointer;
      text-align: center;
      text-decoration: underline dotted #b2e6ff;
      padding: 6px 0;
      transition: color 0.2s;
      user-select: none;
    }
    .custom-img-text:hover, .custom-img-text:active {
      color: #00b894;
      text-decoration: underline solid #00b894;
    }
    @media (max-width: 500px) {
      .custom-img-bar { margin-top: 8vw; }
      .custom-img-text { font-size: 1em; padding: 8px 10vw; }
    }
    /* ê°„ë‹¨ í¬ë¡­ ëª¨ë‹¬ ìŠ¤íƒ€ì¼ */
    #cropModal {
      position: fixed;
      left: 0; top: 0; right: 0; bottom: 0;
      width: 100vw; height: 100vh;
      background: rgba(186,230,253,0.85);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    .simple-crop-container {
      padding: 12px 8px 24px 8px;
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
      max-width: 95vw;
      max-height: 90vh;
      overflow-y: auto;
      box-sizing: border-box;
      background: #fff;
      border-radius: 20px;
      box-shadow: 0 4px 24px #b2e6ff88, 0 1.5px 8px #f9e7fe44;
    }
    #simpleCropCanvas {
      display: block;
      background: #fff;
      border-radius: 50%;
      margin-bottom: 12px;
      box-shadow: 0 1.5px 8px #b2e6ff33;
    }
    .crop-btn {
      background: linear-gradient(90deg, #f9e7fe 0%, #b2e6ff 100%);
      color: #7d5fff;
      border: none;
      border-radius: 12px;
      padding: 8px 28px;
      font-size: 1.08em;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 2px 8px #b2e6ff33;
      transition: background 0.2s, color 0.2s, transform 0.1s;
      margin: 0 8px;
    }
    .crop-btn:hover, .crop-btn:active {
      background: linear-gradient(90deg, #b2e6ff 0%, #f9e7fe 100%);
      color: #00b894;
      transform: scale(1.04);
    }
    .crop-step {
      color: #7d5fff;
      font-size: 1.05em;
      font-weight: bold;
      margin-bottom: 8px;
      text-align: center;
    }
    .crop-slider-bar {
      width: 220px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .crop-slider-bar input[type=range] {
      flex: 1;
    }
    .crop-slider-label {
      color: #7d5fff;
      font-size: 0.98em;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ’–ì‹¬ì‹¬í• ë•Œ ìˆ˜ë°•ê²Œì„ğŸ’–</h1>
    <div class="scoreboard">
      <span class="score">ì ìˆ˜: <span id="score">0</span></span>
      <button class="reset-btn" onclick="resetGame()">ë¦¬ì…‹</button>
    </div>
    <canvas id="gameCanvas" width="360" height="450"></canvas>
    <div class="custom-img-bar">
      <span id="toggleCustomImgText" class="custom-img-text" onclick="toggleCustomImgMode()">ë‚´ê°€ ì›í•˜ëŠ” ì‚¬ì§„ìœ¼ë¡œ í”Œë ˆì´í•˜ê¸°</span>
      <input type="file" id="customImgInput" accept="image/*" multiple style="display:none" onchange="handleCustomImgUpload(event)">
    </div>
    <div id="gameOverLayer" style="display:none;">
      <div class="gameover-content">
        <div class="gameover-title">ê²Œì„ ì˜¤ë²„!</div>
        <div class="gameover-score">ì ìˆ˜: <span id="finalScore">0</span></div>
        <button class="gameover-btn" onclick="resetGame()">ë‹¤ì‹œ ì‹œì‘</button>
      </div>
    </div>
  </div>
  <div id="cropModal">
    <div class="simple-crop-container">
      <div class="crop-step" id="cropStepText"></div>
      <canvas id="simpleCropCanvas" width="240" height="240"></canvas>
      <div class="crop-slider-bar">
        <span class="crop-slider-label">í™•ëŒ€</span>
        <input type="range" id="cropScaleSlider" min="1" max="2.5" step="0.01" value="1">
      </div>
      <div class="crop-btn-bar">
        <button class="crop-btn" onclick="applyCrop()">ì ìš©</button>
        <button class="crop-btn" onclick="skipCrop()">ê±´ë„ˆë›°ê¸°</button>
      </div>
    </div>
  </div>
  <div id="selectPhotoModal" style="display:none; position:fixed; left:0; top:0; right:0; bottom:0; width:100vw; height:100vh; background:rgba(186,230,253,0.85); z-index:1000; align-items:center; justify-content:center;">
    <div class="simple-crop-container" style="min-width:260px;">
      <div class="crop-step" style="margin-bottom:18px;">ì‚¬ì§„ 10ì¥ì„ ì„ íƒí•´ ì£¼ì„¸ìš”</div>
      <button class="crop-btn" onclick="openPhotoPicker()">ì‚¬ì§„ì²© ì—´ê¸°</button>
    </div>
  </div>
  <script>
    // ê¸°ë³¸ ê³¼ì¼ ì´ë¯¸ì§€(ìƒ‰ìƒ ì›ìœ¼ë¡œ ëŒ€ì²´)
    const fruitColors = ["#f7e967", "#f9b233", "#ff7f50", "#ff4e50", "#a3e048", "#4ecdc4", "#3aaf85", "#2e86de", "#8e44ad", "#2d3436"];
    const fruitNames = ["ì²´ë¦¬", "ê·¤", "ìë‘", "ë³µìˆ­ì•„", "ì‚¬ê³¼", "ë°°", "í¬ë„", "ë©œë¡ ", "ì°¸ì™¸", "ìˆ˜ë°•"];
    const fruitEmojis = ["ğŸ’", "ğŸ¥", "ğŸŠ", "ğŸ…", "ğŸ‘", "ğŸ", "ğŸ", "ğŸ‡", "ğŸˆ", "ğŸ‰"];
    const minRadius = 12;
    const fruitRadius = [
      minRadius, // 1ë‹¨ê³„
      minRadius * 2, // 2ë‹¨ê³„(2ë°°)
      minRadius * 2 * 1.7, // 3ë‹¨ê³„(1.7ë°°)
      minRadius * 2 * 1.7 * 1.5, // 4ë‹¨ê³„(1.5ë°°)
      minRadius * 2 * 1.7 * 1.5 * 1.3, // 5ë‹¨ê³„(1.3ë°°)
      minRadius * 2 * 1.7 * 1.5 * 1.3 * 1.2, // 6ë‹¨ê³„(1.2ë°°)
      minRadius * 2 * 1.7 * 1.5 * 1.3 * 1.2 * 1.2, // 7ë‹¨ê³„(1.2ë°°)
      minRadius * 2 * 1.7 * 1.5 * 1.3 * 1.2 * 1.2 * 1.2, // 8ë‹¨ê³„(1.2ë°°)
      minRadius * 2 * 1.7 * 1.5 * 1.3 * 1.2 * 1.2 * 1.2 * 1.2, // 9ë‹¨ê³„(1.2ë°°)
      minRadius * 2 * 1.7 * 1.5 * 1.3 * 1.2 * 1.2 * 1.2 * 1.2 * 1.2 // 10ë‹¨ê³„(1.2ë°°)
    ];
    const GRAVITY = 0.5;
    const FRICTION = 0.97;
    const BOUNCE = 0.4;
    const STOP_VELOCITY = 0.8;
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    let fruits = [];
    let currentFruit = null;
    let score = 0;
    let isGameOver = false;
    let mergeCooldown = false;
    let mergeFruitsPending = false;
    // ì»¤ìŠ¤í…€ ì´ë¯¸ì§€ ëª¨ë“œ ìƒíƒœ ë° ì´ë¯¸ì§€ ì €ì¥
    let customFruitImages = Array(10).fill(null); // ê° ê³¼ì¼ íƒ€ì…ë³„ ì´ë¯¸ì§€ ê°ì²´
    let useCustomImages = false;
    // ê°„ë‹¨ í¬ë¡­ ê´€ë ¨ ë³€ìˆ˜
    let cropFiles = [];
    let cropIdx = 0;
    let cropImgs = Array(10).fill(null);
    let cropImgObj = null;
    let cropScale = 1;
    // ë“œë˜ê·¸ ì´ë™ìš© ë³€ìˆ˜
    let cropOffsetX = 0;
    let cropOffsetY = 0;
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;
    let dragOriginOffsetX = 0;
    let dragOriginOffsetY = 0;

    function drawFruit(fruit) {
      let radius = fruitRadius[fruit.type];
      let y = Math.max(radius, Math.min(canvas.height - radius, fruit.y));
      if (fruit.mergeAnim && fruit.mergeAnim > 0) {
        radius *= 1 + 0.5 * fruit.mergeAnim;
      }
      ctx.save();
      ctx.translate(fruit.x, y);
      ctx.rotate(fruit.angle || 0);
      if (useCustomImages && customFruitImages[fruit.type]) {
        // ì›í˜• ë§ˆìŠ¤í‚¹ í›„ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
        ctx.save();
        ctx.beginPath();
        ctx.arc(0, 0, radius, 0, Math.PI * 2);
        ctx.closePath();
        ctx.clip();
        ctx.drawImage(customFruitImages[fruit.type], -radius, -radius, radius * 2, radius * 2);
        ctx.restore();
      } else {
        ctx.font = `${radius * 2}px serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(fruitEmojis[fruit.type], 0, 0);
      }
      ctx.restore();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (const fruit of fruits) drawFruit(fruit);
      if (currentFruit) drawFruit(currentFruit);
    }

    function updatePhysics(fruit, isCurrent) {
      // ì¤‘ë ¥ ë° ì´ë™ ì ìš© (ê°€ì¥ ë¨¼ì €!)
      fruit.vy += GRAVITY;
      fruit.x += fruit.vx;
      fruit.y += fruit.vy;
      // stopped ìƒíƒœì—¬ë„ ê²¹ì¹¨ í•´ì†Œ ë°˜ì‘ì€ í•­ìƒ ì‹¤í–‰ (ì—¬ëŸ¬ ë²ˆ ë°˜ë³µ)
      for (let rep = 0; rep < 20; rep++) {
        for (const other of fruits) {
          if (other === fruit) continue;
          const dx = fruit.x - other.x;
          const dy = fruit.y - other.y;
          const dist = Math.sqrt(dx*dx + dy*dy);
          const minDist = fruitRadius[fruit.type] + fruitRadius[other.type];
          if (dist < minDist && dist > 0.01) {
            // ê²¹ì¹¨ í•´ì†Œ(ìƒí˜¸ì‘ìš© ë°œìƒ)
            const angle = Math.atan2(dy, dx);
            const overlap = minDist - dist;
            const totalMass = fruit.mass + other.mass;
            const fruitMoveRatio = other.mass / totalMass;
            const otherMoveRatio = fruit.mass / totalMass;
            const moveX = Math.cos(angle) * (overlap * fruitMoveRatio);
            const moveY = Math.sin(angle) * (overlap * fruitMoveRatio);
            fruit.x += moveX;
            fruit.y += moveY;
            other.x -= Math.cos(angle) * (overlap * otherMoveRatio);
            other.y -= Math.sin(angle) * (overlap * otherMoveRatio);
            // í‘œë©´ ì ‘ì„  ë°©í–¥ìœ¼ë¡œ vxì— vyë¥¼ ì ë‹¹íˆ ë³€í™˜ (ìµœì†Œ/ìµœëŒ€ê°’ clamp)
            const transfer = 0.05; // í›¨ì”¬ ë” ëŠë¦¬ê²Œ
            const sign = Math.sign(dx) || 1;
            if (fruit.y > other.y) {
              fruit.vy = 0;
              if (Math.abs(fruit.vx) < 0.15) {
                fruit.vx += sign * transfer;
              }
              const maxVX = 0.2;
              if (fruit.vx > maxVX) fruit.vx = maxVX;
              if (fruit.vx < -maxVX) fruit.vx = -maxVX;
              // ì°©ì§€ íŒì •ì€ í•˜ì§€ ì•ŠìŒ (ê³„ì† í‘œë©´ ë¯¸ë„ëŸ¬ì§)
            } else {
              if (fruit.vy === 0) {
                fruit.vy = 2;
              }
              if (isCurrent) return true;
            }
          }
        }
      }
      let onSurface = false;
      if (!isCurrent) { // currentFruitì—ëŠ” í‘œë©´ ë©ˆì¶¤ ë¡œì§ ì ìš©í•˜ì§€ ì•ŠìŒ
        for (const other of fruits) {
          if (other === fruit || !other.stopped) continue;
          const dx = fruit.x - other.x;
          const dy = fruit.y - other.y;
          const dist = Math.sqrt(dx*dx + dy*dy);
          const minDist = fruitRadius[fruit.type] + fruitRadius[other.type];
          if (
            dist < minDist + 0.5 &&
            fruit.y + fruitRadius[fruit.type] >= other.y - fruitRadius[other.type] &&
            fruit.y < other.y &&
            fruit.vy > 0 &&
            fruit.vy < 1.5
          ) {
            // í‘œë©´ ìœ„ì— ì˜¬ë ¤ë†“ê¸°
            const angle = Math.atan2(dy, dx);
            fruit.x = other.x + Math.cos(angle) * minDist;
            fruit.y = other.y + Math.sin(angle) * minDist;
            fruit.vy = 0; // vyë¥¼ ë¬´ì¡°ê±´ 0ìœ¼ë¡œ ê³ ì •
            fruit.vx *= FRICTION;
            onSurface = true;
            if (Math.abs(fruit.vx) < 0.05 && Math.abs(fruit.vy) < 0.05) {
              fruit.vx = 0;
              fruit.vy = 0;
              fruit.stopped = true;
            }
            break;
          }
        }
      }
      // ë°”ë‹¥ ì¶©ëŒ
      if (!onSurface && fruit.y + fruitRadius[fruit.type] > canvas.height) {
        fruit.y = canvas.height - fruitRadius[fruit.type];
        // ë°”ë‹¥ì— ì°©ì§€í•˜ëŠ” ìˆœê°„ì—ë§Œ ë°”ìš´ìŠ¤ íš¨ê³¼ ì ìš©
        if (fruit.vy > 0.5) {
          fruit.vy = -fruit.vy * BOUNCE * 1.2;
        } else {
          fruit.vy = 0;
        }
        fruit.vx *= FRICTION;
        if (Math.abs(fruit.vy) < 0.2 && Math.abs(fruit.vx) < 0.2) {
          fruit.vx = 0;
          fruit.vy = 0;
          fruit.stopped = true;
          if (isCurrent) return true;
        }
      }
      // ë²½ ì¶©ëŒ (ì™¼ìª½/ì˜¤ë¥¸ìª½) - ë§ˆì§€ë§‰ì— í•œ ë²ˆ ë” ë³´ì •
      if (fruit.x - fruitRadius[fruit.type] < 0) {
        fruit.x = fruitRadius[fruit.type];
        fruit.vx *= -BOUNCE * 0.5; // ê°ì‡  ë” ê°•í•˜ê²Œ
        if (Math.abs(fruit.vx) < 0.3 && Math.abs(fruit.vy) < 0.3) {
          fruit.vx = 0;
          fruit.vy = 0;
          fruit.stopped = true;
          if (isCurrent) return true;
        }
      }
      if (fruit.x + fruitRadius[fruit.type] > canvas.width) {
        fruit.x = canvas.width - fruitRadius[fruit.type];
        fruit.vx *= -BOUNCE * 0.5; // ê°ì‡  ë” ê°•í•˜ê²Œ
        if (Math.abs(fruit.vx) < 0.3 && Math.abs(fruit.vy) < 0.3) {
          fruit.vx = 0;
          fruit.vy = 0;
          fruit.stopped = true;
          if (isCurrent) return true;
        }
      }
      // ìº”ë²„ìŠ¤ ìƒë‹¨ë„ ë²—ì–´ë‚˜ì§€ ì•Šê²Œ
      if (fruit.y - fruitRadius[fruit.type] < 0) {
        fruit.y = fruitRadius[fruit.type];
        fruit.vy = 0;
      }
      // ë‹¤ë¥¸ ê³¼ì¼ê³¼ ì¶©ëŒ
      for (const other of fruits) {
        if (other === fruit) continue;
        // ë©ˆì¶˜ ê³¼ì¼ì´ë©´ ì†ë„ ì „ë‹¬/êµí™˜í•˜ì§€ ì•ŠìŒ
        if (fruit.stopped || other.stopped) continue;
        const dx = fruit.x - other.x;
        const dy = fruit.y - other.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const minDist = fruitRadius[fruit.type] + fruitRadius[other.type];
        if (dist < minDist) {
          // ê²¹ì¹¨ í•´ì†Œ(í•­ìƒ)
          const angle = Math.atan2(dy, dx);
          const overlap = minDist - dist;
          const totalMass = fruit.mass + other.mass;
          const fruitMoveRatio = other.mass / totalMass;
          const otherMoveRatio = fruit.mass / totalMass;
          const moveX = Math.cos(angle) * (overlap * fruitMoveRatio);
          const moveY = Math.sin(angle) * (overlap * fruitMoveRatio);
          console.log('ê²¹ì¹¨í•´ì†Œ', {fruitType: fruit.type, otherType: other.type, fruitMass: fruit.mass, otherMass: other.mass, moveX, moveY, fruitX: fruit.x, otherX: other.x});
          fruit.x += moveX;
          fruit.y += moveY;
          other.x -= Math.cos(angle) * (overlap * otherMoveRatio);
          other.y -= Math.sin(angle) * (overlap * otherMoveRatio);
          // ì†ë„ êµí™˜(ê°„ë‹¨) - ë©ˆì¶˜ ê³¼ì¼ì€ ì œì™¸
          if (!(fruit.stopped || other.stopped)) {
            // ìš´ë™ëŸ‰ ë³´ì¡´ ê¸°ë°˜ ì†ë„ ë¶„ë°°
            const newVx1 = (fruit.vx * (fruit.mass - other.mass) + 2 * other.mass * other.vx) / totalMass;
            const newVx2 = (other.vx * (other.mass - fruit.mass) + 2 * fruit.mass * fruit.vx) / totalMass;
            fruit.vx = newVx1;
            other.vx = newVx2;
            // vyë„ ë™ì¼í•˜ê²Œ ì ìš© ê°€ëŠ¥
            const newVy1 = (fruit.vy * (fruit.mass - other.mass) + 2 * other.mass * other.vy) / totalMass;
            const newVy2 = (other.vy * (other.mass - fruit.mass) + 2 * fruit.mass * fruit.vy) / totalMass;
            fruit.vy = newVy1;
            other.vy = newVy2;
          } else if (other.stopped) {
            // ì‘ì€ ê³¼ì¼ì´ ë©ˆì¶° ìˆì„ ë•Œ, í° ê³¼ì¼ì´ ì‘ì€ ê³¼ì¼ì„ ë°€ê³  í•¨ê»˜ êµ´ëŸ¬ê°€ê²Œ
            other.vx = fruit.vx * 0.9;
            fruit.vx *= 0.9;
          }
          // ì¶©ë¶„íˆ ëŠë ¤ì§€ë©´ ë©ˆì¶¤
          if (Math.abs(fruit.vy) < 0.5 && Math.abs(fruit.vx) < 0.5) {
            fruit.vy = 0;
            fruit.vx = 0;
            fruit.stopped = true;
          }
          if (isCurrent && fruit.stopped) return true;
        }
        // ê²¹ì¹¨ í•´ì†Œ(ìœ„ì¹˜ ë³´ì •)ì—ì„œ ì§ˆëŸ‰ì´ í° ê³¼ì¼ì´ ì•„ë˜ì— ì˜¤ë„ë¡ ë³´ì •
        if (fruit.mass > other.mass && fruit.y < other.y) {
          // í° ê³¼ì¼ì´ ìœ„ì— ìˆê³ , ì‘ì€ ê³¼ì¼ì´ ì•„ë˜ì— ìˆìœ¼ë©´ ìœ„ì¹˜ë¥¼ ë°”ê¿”ì¤Œ
          const tempY = fruit.y;
          fruit.y = other.y;
          other.y = tempY;
        }
      }
      // ë§ˆì°° ì ìš©
      fruit.vx *= FRICTION;
      fruit.vy *= FRICTION;
      // íšŒì „ ì†ë„ ë° ê°ë„ ì—…ë°ì´íŠ¸ (vxì— ë¹„ë¡€)
      fruit.angularVelocity = fruit.vx / (fruitRadius[fruit.type] * 0.7); // ë°˜ì§€ë¦„ì— ë¹„ë¡€, 0.7ì€ íŠœë‹ê°’
      fruit.angle += fruit.angularVelocity;
      // angle ê°’ì´ ë„ˆë¬´ ì»¤ì§€ì§€ ì•Šê²Œ -íŒŒì´~íŒŒì´ ë²”ìœ„ë¡œ ìœ ì§€
      if (fruit.angle > Math.PI) fruit.angle -= 2 * Math.PI;
      if (fruit.angle < -Math.PI) fruit.angle += 2 * Math.PI;
      // vx, vyê°€ ì¶©ë¶„íˆ ì‘ìœ¼ë©´ 0ìœ¼ë¡œ ê³ ì • (ì§„ë™ ë°©ì§€, ë” ì—„ê²©í•˜ê²Œ)
      if (Math.abs(fruit.vx) < 0.1) fruit.vx = 0;
      if (Math.abs(fruit.vy) < 0.1) fruit.vy = 0;
      // ë©ˆì¶¤ íŒì • (ì¡°ê¸ˆ ë” ì™„í™”)
      if (Math.abs(fruit.vx) < 0.05 && Math.abs(fruit.vy) < 0.05 && fruit.y + fruitRadius[fruit.type] >= canvas.height - 1) {
        fruit.vx = 0;
        fruit.vy = 0;
        fruit.stopped = true;
      }
      // ê²¹ì¹¨ í•´ì†Œ/ìœ„ì¹˜ ë³´ì • ì§í›„, return false ì§ì „ì—ë§Œ clamp ìœ ì§€
      if (fruit.y + fruitRadius[fruit.type] > canvas.height) {
        fruit.y = canvas.height - fruitRadius[fruit.type];
        if (fruit.vy > 0) fruit.vy = 0;
      }
      // ë°”ë‹¥ì—ì„œ vx ê°ì‡ /ê³ ì •
      fruit.vx *= 0.97;
      if (Math.abs(fruit.vx) < 0.01) fruit.vx = 0;
      // vy==0ì´ì–´ë„ vxëŠ” 0ìœ¼ë¡œ ë§Œë“¤ì§€ ì•ŠìŒ
      let wasOnSurface = fruit.wasOnSurfaceLastFrame || false;
      fruit.wasOnSurfaceLastFrame = onSurface;
      if (!onSurface && wasOnSurface) {
        // ì§ì „ í”„ë ˆì„ì— í‘œë©´ì— ìˆì—ˆê³ , ì´ë²ˆ í”„ë ˆì„ì— ë–¨ì–´ì§„ ê²½ìš°
        const minVX = 0.5;
        const sign = Math.sign(fruit.vx) || 1;
        fruit.vx += sign * minVX;
        if (fruit.vy > 2) fruit.vy = 2;
      }
      return false;
    }

    function gameLoop() {
      // currentFruit ë¬¼ë¦¬ ì ìš©
      if (currentFruit) {
        if (currentFruit.dropping) {
          const landed = updatePhysics(currentFruit, true);
          if (landed) {
            fruits.push(currentFruit);
            currentFruit = null;
            mergeFruitsPending = true;
            setTimeout(spawnFruit, 400);
          }
        }
      }
      // ê¸°ì¡´ ê³¼ì¼ ë¬¼ë¦¬ ì ìš© ë° í•©ì²´ ì• ë‹ˆë©”ì´ì…˜ ì²˜ë¦¬
      for (const fruit of fruits) {
        updatePhysics(fruit, false);
        if (fruit.mergeAnim && fruit.mergeAnim > 0) {
          fruit.mergeAnim -= 0.08;
          if (fruit.mergeAnim < 0) fruit.mergeAnim = 0;
        }
      }
      draw();
      // ì—°ì‡„ í•©ì²´ í”„ë ˆì„ ë¶„ë¦¬
      if (mergeFruitsPending || mergeFruits()) {
        mergeFruitsPending = false;
        requestAnimationFrame(gameLoop);
        return;
      }
      requestAnimationFrame(gameLoop);
    }

    function spawnFruit() {
      if (isGameOver) return;
      currentFruit = {
        x: canvas.width / 2,
        y: fruitRadius[0],
        type: 0,
        vx: 0,
        vy: 2,
        stopped: false,
        dropping: false, // ë“œë˜ê·¸ ëë‚˜ë©´ trueë¡œ ë³€ê²½
        mass: fruitRadius[0] * fruitRadius[0],
        wasOnSurfaceLastFrame: false,
        angle: 0,
        angularVelocity: 0
      };
      draw();
    }

    function mergeFruits() {
      if (mergeCooldown) return false;
      console.log('mergeFruits í˜¸ì¶œ', fruits, currentFruit);
      for (let i = 0; i < fruits.length; i++) {
        for (let j = i + 1; j < fruits.length; j++) {
          if (fruits[i].type === fruits[j].type) {
            console.log('ê°•ì œ í•©ì²´!', fruits[i], fruits[j]);
            const newType = fruits[i].type + 1;
            if (newType >= fruitRadius.length) continue;
            // ë‘ ê³¼ì¼ì˜ ì ‘ì (ì¶©ëŒ ìœ„ì¹˜) ê³„ì‚°
            const dx = fruits[i].x - fruits[j].x;
            const dy = fruits[i].y - fruits[j].y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < fruitRadius[fruits[i].type] + fruitRadius[fruits[j].type] + 8) {
              // í•©ì²´ ì§ì „, ê¸°ì¡´ ë‘ ê³¼ì¼ì— ë°˜ëŒ€ ë°©í–¥ ì†ë„ ì‚´ì§ ë¶€ì—¬
              const angle = Math.atan2(dy, dx);
              const bounceSpeed = 1;
              const maxBounce = 2;
              fruits[i].vx = Math.max(-maxBounce, Math.min(maxBounce, Math.cos(angle) * bounceSpeed));
              fruits[i].vy = Math.max(-maxBounce, Math.min(maxBounce, Math.sin(angle) * bounceSpeed));
              fruits[j].vx = Math.max(-maxBounce, Math.min(maxBounce, -Math.cos(angle) * bounceSpeed));
              fruits[j].vy = Math.max(-maxBounce, Math.min(maxBounce, -Math.sin(angle) * bounceSpeed));
              // ìƒˆë¡œ ë§Œë“¤ì–´ì§„ ê³¼ì¼ì˜ ì†ë„ëŠ” í‰ê· ì˜ 1/24ë¡œ ì²œì²œíˆ
              const upper = fruits[i].y < fruits[j].y ? fruits[i] : fruits[j];
              const lower = fruits[i].y > fruits[j].y ? fruits[i] : fruits[j];
              const newFruit = {
                x: fruits[i].x,
                y: fruits[i].y,
                type: newType,
                vx: 0,
                vy: 2,
                stopped: false,
                dropping: true,
                mergeAnim: 1.0,
                mass: fruitRadius[newType] * fruitRadius[newType],
                wasOnSurfaceLastFrame: false,
                angle: 0,
                angularVelocity: 0
              };
              newFruit.x = Math.max(fruitRadius[newType], Math.min(canvas.width - fruitRadius[newType], newFruit.x));
              newFruit.y = Math.max(fruitRadius[newType], Math.min(canvas.height - fruitRadius[newType], newFruit.y));
              if (j > i) {
                fruits.splice(j, 1);
                fruits.splice(i, 1);
              } else {
                fruits.splice(i, 1);
                fruits.splice(j, 1);
              }
              fruits.push(newFruit);
              score += (newType + 1) * 10;
              document.getElementById('score').textContent = score;
              draw();
              mergeCooldown = true;
              setTimeout(() => { mergeCooldown = false; }, 600); // 600ms ì¿¨íƒ€ì„
              return true;
            }
          }
        }
      }
      return false;
    }

    // ë§ˆìš°ìŠ¤/í„°ì¹˜ë¡œ ê³¼ì¼ ìœ„ì¹˜ ì¡°ì •(ë“œë˜ê·¸)
    let dragging = false;
    canvas.addEventListener('mousedown', e => {
      if (!currentFruit || currentFruit.dropping) return;
      dragging = true;
    });
    canvas.addEventListener('mousemove', e => {
      if (!currentFruit || !dragging || currentFruit.dropping) return;
      const rect = canvas.getBoundingClientRect();
      let x = e.clientX - rect.left;
      x = Math.max(fruitRadius[0], Math.min(canvas.width - fruitRadius[0], x));
      currentFruit.x = x;
      currentFruit.y = fruitRadius[0]; // ë“œë˜ê·¸ ì¤‘ì—ë§Œ yì¢Œí‘œ ê³ ì •
      draw();
    });
    canvas.addEventListener('mouseup', e => {
      if (!currentFruit || !dragging || currentFruit.dropping) return;
      dragging = false;
      // ë“œë¡­ ì‹œ ì•½ê°„ì˜ ì†ë„ ë¶€ì—¬, dropping ì‹œì‘
      currentFruit.vx = (Math.random() - 0.5) * 2;
      currentFruit.vy = 2; // ë°˜ë“œì‹œ ë‚™í•˜ê°€ ì‹œì‘ë˜ë„ë¡!
      // currentFruit.y = 40; // yì¢Œí‘œë¥¼ ë³€ê²½í•˜ì§€ ì•ŠìŒ
      currentFruit.stopped = false;
      currentFruit.dropping = true;
    });
    // ëª¨ë°”ì¼ í„°ì¹˜ ì§€ì›
    canvas.addEventListener('touchstart', e => {
      if (!currentFruit || currentFruit.dropping) return;
      dragging = true;
      e.preventDefault();
    });
    canvas.addEventListener('touchmove', e => {
      if (!currentFruit || !dragging || currentFruit.dropping) return;
      const rect = canvas.getBoundingClientRect();
      let x = e.touches[0].clientX - rect.left;
      x = Math.max(fruitRadius[0], Math.min(canvas.width - fruitRadius[0], x));
      currentFruit.x = x;
      draw();
      e.preventDefault();
    });
    canvas.addEventListener('touchend', e => {
      if (!currentFruit || !dragging || currentFruit.dropping) return;
      dragging = false;
      currentFruit.vx = (Math.random() - 0.5) * 2;
      currentFruit.vy = 2; // ë°˜ë“œì‹œ ë‚™í•˜ê°€ ì‹œì‘ë˜ë„ë¡!
      // currentFruit.y = 40; // yì¢Œí‘œë¥¼ ë³€ê²½í•˜ì§€ ì•ŠìŒ
      currentFruit.stopped = false;
      currentFruit.dropping = true;
      e.preventDefault();
    });

    function resetGame() {
      fruits = [];
      currentFruit = null;
      score = 0;
      isGameOver = false;
      document.getElementById('score').textContent = score;
      hideGameOverLayer();
      draw();
      spawnFruit();
    }

    // ê²Œì„ ì˜¤ë²„ ì²´í¬(ë ˆì´ì–´ë¡œ í‘œì‹œ)
    function checkGameOver() {
      for (const fruit of fruits) {
        if (fruit.y - fruitRadius[fruit.type] < 0) {
          isGameOver = true;
          showGameOverLayer();
          break;
        }
      }
    }

    function showGameOverLayer() {
      document.getElementById('finalScore').textContent = score;
      document.getElementById('gameOverLayer').style.display = 'flex';
    }

    function hideGameOverLayer() {
      document.getElementById('gameOverLayer').style.display = 'none';
    }

    // ê²Œì„ ë£¨í”„
    setInterval(() => {
      if (!isGameOver) checkGameOver();
    }, 500);

    // ì‹œì‘
    resetGame();
    requestAnimationFrame(gameLoop);

    function toggleCustomImgMode() {
      if (!useCustomImages) {
        // ì‚¬ì§„ ëª¨ë“œë¡œ ì „í™˜: ì•ˆë‚´ ëª¨ë‹¬ ë¨¼ì € ë„ìš°ê¸°
        document.getElementById('selectPhotoModal').style.display = 'flex';
      } else {
        // ì´ëª¨ì§€ ëª¨ë“œë¡œ ì „í™˜
        useCustomImages = false;
        customFruitImages = Array(10).fill(null);
        updateCustomImgBtn();
        draw();
      }
    }

    function updateCustomImgBtn() {
      const txt = document.getElementById('toggleCustomImgText');
      if (useCustomImages) {
        txt.textContent = 'ë‹¤ì‹œ ì´ëª¨ì§€ë¡œ í”Œë ˆì´í•˜ê¸°';
      } else {
        txt.textContent = 'ë‚´ê°€ ì›í•˜ëŠ” ì‚¬ì§„ìœ¼ë¡œ í”Œë ˆì´í•˜ê¸°';
      }
    }

    function handleCustomImgUpload(e) {
      const files = Array.from(e.target.files).slice(0, 10);
      if (files.length !== 10) {
        alert('ì‚¬ì§„ì„ 10ì¥ ëª¨ë‘ ì„ íƒí•´ ì£¼ì„¸ìš”!');
        return;
      }
      cropFiles = files;
      cropIdx = 0;
      cropImgs = Array(10).fill(null);
      showCropModal();
      e.target.value = '';
    }

    function showCropModal() {
      if (cropIdx >= cropFiles.length) {
        // í¬ë¡­ ì™„ë£Œ
        customFruitImages = cropImgs.slice();
        useCustomImages = true;
        updateCustomImgBtn();
        draw();
        document.getElementById('cropModal').style.display = 'none';
        return;
      }
      // í˜„ì¬ íŒŒì¼ ë¯¸ë¦¬ë³´ê¸°
      const reader = new FileReader();
      reader.onload = function(ev) {
        cropImgObj = new window.Image();
        cropImgObj.onload = function() {
          cropScale = 1;
          document.getElementById('cropScaleSlider').value = 1;
          cropOffsetX = 0;
          cropOffsetY = 0;
          drawSimpleCropPreview();
        };
        cropImgObj.src = ev.target.result;
      };
      reader.readAsDataURL(cropFiles[cropIdx]);
      document.getElementById('cropStepText').innerHTML = `${cropIdx+1}ë²ˆ ì´ë¯¸ì§€ ì˜ì—­ì„ ì§€ì •í•´ ì£¼ì„¸ìš”<br/>(ìŠ¬ë¼ì´ë”ë¡œ í™•ëŒ€/ì¶•ì†Œ, ë“œë˜ê·¸ë¡œ ìœ„ì¹˜ ì´ë™)`;
      document.getElementById('cropModal').style.display = 'flex';
    }

    document.getElementById('cropScaleSlider').addEventListener('input', function(e) {
      cropScale = parseFloat(e.target.value);
      drawSimpleCropPreview();
    });

    function drawSimpleCropPreview() {
      const canvas = document.getElementById('simpleCropCanvas');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!cropImgObj) return;
      // ì›í˜• ë§ˆìŠ¤í‚¹
      ctx.save();
      ctx.beginPath();
      ctx.arc(canvas.width/2, canvas.height/2, canvas.width/2, 0, Math.PI*2);
      ctx.closePath();
      ctx.clip();
      // ì¤‘ì•™ ê¸°ì¤€ cropScaleë§Œí¼ í™•ëŒ€í•´ì„œ ê·¸ë¦¼ + ì˜¤í”„ì…‹ ì ìš©
      const minDim = Math.min(cropImgObj.width, cropImgObj.height);
      const cropSize = minDim / cropScale;
      let sx = (cropImgObj.width - cropSize) / 2 + cropOffsetX * cropSize / 240;
      let sy = (cropImgObj.height - cropSize) / 2 + cropOffsetY * cropSize / 240;
      // ê²½ê³„ ì²´í¬(ì´ë¯¸ì§€ê°€ ì› ë°–ìœ¼ë¡œ ë„ˆë¬´ ë²—ì–´ë‚˜ì§€ ì•Šê²Œ)
      sx = Math.max(0, Math.min(cropImgObj.width - cropSize, sx));
      sy = Math.max(0, Math.min(cropImgObj.height - cropSize, sy));
      ctx.drawImage(cropImgObj, sx, sy, cropSize, cropSize, 0, 0, canvas.width, canvas.height);
      ctx.restore();
      // ì›í˜• ê°€ì´ë“œ(í…Œë‘ë¦¬)
      ctx.save();
      ctx.beginPath();
      ctx.arc(canvas.width/2, canvas.height/2, canvas.width/2-2, 0, Math.PI*2);
      ctx.strokeStyle = '#7d5fff';
      ctx.lineWidth = 2.5;
      ctx.stroke();
      ctx.restore();
    }

    // ë“œë˜ê·¸ ì´ë²¤íŠ¸(ë§ˆìš°ìŠ¤)
    const cropCanvas = document.getElementById('simpleCropCanvas');
    cropCanvas.addEventListener('mousedown', function(e) {
      isDragging = true;
      dragStartX = e.offsetX;
      dragStartY = e.offsetY;
      dragOriginOffsetX = cropOffsetX;
      dragOriginOffsetY = cropOffsetY;
    });
    window.addEventListener('mousemove', function(e) {
      if (!isDragging) return;
      const rect = cropCanvas.getBoundingClientRect();
      const dx = e.clientX - rect.left - dragStartX;
      const dy = e.clientY - rect.top - dragStartY;
      cropOffsetX = dragOriginOffsetX - dx;
      cropOffsetY = dragOriginOffsetY - dy;
      drawSimpleCropPreview();
    });
    window.addEventListener('mouseup', function(e) {
      isDragging = false;
    });
    // ë“œë˜ê·¸ ì´ë²¤íŠ¸(í„°ì¹˜)
    cropCanvas.addEventListener('touchstart', function(e) {
      if (e.touches.length !== 1) return;
      isDragging = true;
      const rect = cropCanvas.getBoundingClientRect();
      dragStartX = e.touches[0].clientX - rect.left;
      dragStartY = e.touches[0].clientY - rect.top;
      dragOriginOffsetX = cropOffsetX;
      dragOriginOffsetY = cropOffsetY;
      e.preventDefault();
    });
    window.addEventListener('touchmove', function(e) {
      if (!isDragging || e.touches.length !== 1) return;
      const rect = cropCanvas.getBoundingClientRect();
      const dx = e.touches[0].clientX - rect.left - dragStartX;
      const dy = e.touches[0].clientY - rect.top - dragStartY;
      cropOffsetX = dragOriginOffsetX - dx;
      cropOffsetY = dragOriginOffsetY - dy;
      drawSimpleCropPreview();
      e.preventDefault();
    }, {passive:false});
    window.addEventListener('touchend', function(e) {
      isDragging = false;
    });

    function applyCrop() {
      if (!cropImgObj) return;
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = 320;
      const ctx = canvas.getContext('2d');
      ctx.save();
      ctx.beginPath();
      ctx.arc(160, 160, 160, 0, Math.PI * 2);
      ctx.closePath();
      ctx.clip();
      // ì¤‘ì•™ ê¸°ì¤€ cropScaleë§Œí¼ í™•ëŒ€í•´ì„œ ê·¸ë¦¼ + ì˜¤í”„ì…‹ ì ìš©
      const minDim = Math.min(cropImgObj.width, cropImgObj.height);
      const cropSize = minDim / cropScale;
      let sx = (cropImgObj.width - cropSize) / 2 + cropOffsetX * cropSize / 240;
      let sy = (cropImgObj.height - cropSize) / 2 + cropOffsetY * cropSize / 240;
      // ê²½ê³„ ì²´í¬(ì´ë¯¸ì§€ê°€ ì› ë°–ìœ¼ë¡œ ë„ˆë¬´ ë²—ì–´ë‚˜ì§€ ì•Šê²Œ)
      sx = Math.max(0, Math.min(cropImgObj.width - cropSize, sx));
      sy = Math.max(0, Math.min(cropImgObj.height - cropSize, sy));
      ctx.drawImage(cropImgObj, sx, sy, cropSize, cropSize, 0, 0, 320, 320);
      ctx.restore();
      const img = new window.Image();
      img.onload = function() {
        cropImgs[cropIdx] = img;
        cropIdx++;
        showCropModal();
      };
      img.src = canvas.toDataURL();
    }

    function skipCrop() {
      cropImgs[cropIdx] = null;
      cropIdx++;
      showCropModal();
    }

    function openPhotoPicker() {
      document.getElementById('selectPhotoModal').style.display = 'none';
      document.getElementById('customImgInput').click();
    }

    // ì‚¬ì§„ ì„ íƒ í›„, í¬ë¡­ ëª¨ë‹¬ì´ ëœ¨ì§€ ì•Šìœ¼ë©´ ì•ˆë‚´ ëª¨ë‹¬ ë‹«ê¸°
    document.getElementById('customImgInput').addEventListener('click', function() {
      document.getElementById('selectPhotoModal').style.display = 'none';
    });
  </script>
</body>
</html>
